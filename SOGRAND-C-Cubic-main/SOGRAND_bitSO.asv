/*
 * Soft-Output GRAND demo on a (15,10) × (15,10) CRC product code
 * – pure ISO-C 11, no external libraries
 *
 * gcc -O3 -std=c11 -lm test_sogrand.c -o test_sogrand
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <math.h>
#include <time.h>

/* ---------- code parameters ----------------------------------------- */
#define K          10          /* information length per row / column   */
#define N          15          /* codeword length                       */
#define R_BITS     (N - K)     /* CRC parity bits (=5)                  */
#define N_MAX      N           /* compile-time upper bound              */

/* ---------- simulation parameters ----------------------------------- */
#define NUM_SIM    1000
#define EB_N0_DB   2.0
#define I_MAX      10
#define L_MAX      4           /* SO-GRAND list size (weight 0 & 1 only)*/
#define ALPHA      0.5
#define SEED       0u          /* 0 = time-based */

/* ---------- (15,10) systematic generator and parity-check ----------- */
/* CRC polynomial 0x15 (binary 1_0101_1) → HD4                         */

static const uint8_t G[K][N] = {
    {1,0,0,0,0,0,0,0,0,0,1,0,1,0,1},
    {0,1,0,0,0,0,0,0,0,0,1,1,1,1,1},
    {0,0,1,0,0,0,0,0,0,0,1,1,0,1,0},
    {0,0,0,1,0,0,0,0,0,0,0,1,1,0,1},
    {0,0,0,0,1,0,0,0,0,0,1,0,0,1,1},
    {0,0,0,0,0,1,0,0,0,0,1,1,1,0,0},
    {0,0,0,0,0,0,1,0,0,0,0,1,1,1,0},
    {0,0,0,0,0,0,0,1,0,0,0,0,1,1,1},
    {0,0,0,0,0,0,0,0,1,0,1,0,1,1,0},
    {0,0,0,0,0,0,0,0,0,1,0,1,0,1,1}
};

static const uint8_t H[R_BITS][N] = {
    {1,1,1,0,1,1,0,0,1,0,1,0,0,0,0},
    {0,1,1,1,0,1,1,0,0,1,0,1,0,0,0},
    {1,1,0,1,0,1,1,1,1,0,0,0,1,0,0},
    {0,1,1,0,1,0,1,1,1,1,0,0,0,1,0},
    {1,1,0,1,1,0,0,1,0,1,0,0,0,0,1}
};

/* ---------- tiny utilities ------------------------------------------ */
static inline double urand(void)
{
    return (double)rand() / (double)RAND_MAX;
}
/* Box-Muller */
static double gauss_rand(void)
{
    double u1 = urand(), u2 = urand();
    return sqrt(-2.0 * log(u1)) * cos(2.0 * M_PI * u2);
}
/* Syndrome check: 1 = valid codeword */
static uint8_t parity_check(const uint8_t *c, const uint8_t (*Hmat)[N],
                            size_t n, size_t s)
{
    for (size_t j = 0; j < s; ++j) {
        uint8_t syn = 0;
        for (size_t i = 0; i < n; ++i)
            syn ^= (c[i] & Hmat[j][i]);
        if (syn) return 0;
    }
    return 1;
}
/* path-metric for hard decision (eq. (4) in SO-GRAND paper) */
static double pm_from_hd(const double *absL, size_t n)
{
    double pm = 0.0;
    for (size_t i = 0; i < n; ++i)
        pm += log1p(exp(-2.0 * absL[i]));  /* log(1+e^(−|L|)) */
    return pm;
}

/* ---------- SO-GRAND (weight-0/1 exhaustive) ------------------------ */
static void sogrand_W01(const double *llr,
                        const uint8_t (*Hmat)[N],
                        double *L_APP,
                        double *L_E)
{
    const size_t n = N, s = R_BITS;

    /* 1. derive HD and |L| */
    uint8_t cHD[N_MAX];
    double  absL[N_MAX];
    for (size_t i = 0; i < n; ++i) {
        cHD[i] = (llr[i] > 0.0) ? 0 : 1;
        absL[i] = fabs(llr[i]);
    }
    double pmHD = pm_from_hd(absL, n);

    /* 2. build list (≤ L_MAX) of codewords with w ≤ 1               */
    uint8_t listC[L_MAX][N_MAX];
    double  listPM[L_MAX];
    size_t  L = 0;

    /* – weight 0 – */
    if (parity_check(cHD, Hmat, n, s)) {
        memcpy(listC[L], cHD, n);
        listPM[L] = pmHD;
        ++L;
    }

    /* – weight 1 – */
    for (size_t pos = 0; pos < n && L < L_MAX; ++pos) {
        uint8_t cand[N_MAX];
        memcpy(cand, cHD, n);
        cand[pos] ^= 1;
        if (parity_check(cand, Hmat, n, s)) {
            memcpy(listC[L], cand, n);
            listPM[L] = pmHD + (llr[pos] > 0.0 ? absL[pos] : -absL[pos]);
            ++L;
        }
    }

    /* 3. soft output */
    for (size_t i = 0; i < n; ++i) {
        double p0 = 0.0, p1 = 0.0;
        for (size_t l = 0; l < L; ++l) {
            double w = exp(-listPM[l]);
            if (listC[l][i]) p1 += w; else p0 += w;
        }
        /* tiny floor to avoid log(0) */
        if (p0 < 1e-300) p0 = 1e-300;
        if (p1 < 1e-300) p1 = 1e-300;

        L_APP[i] = log(p0) - log(p1);
        L_E  [i] = L_APP[i] - llr[i];
    }
}

/* ---------- syndrome-zero for entire product matrix ----------------- */
static int prod_syndrome_zero(uint8_t mat[N][N])
{
    /* rows */
    for (size_t r = 0; r < N; ++r)
        if (!parity_check(mat[r], H, N, R_BITS)) return 0;
    /* columns */
    uint8_t col[N];
    for (size_t c = 0; c < N; ++c) {
        for (size_t i = 0; i < N; ++i) col[i] = mat[i][c];
        if (!parity_check(col, H, N, R_BITS)) return 0;
    }
    return 1;
}

/* ---------- MAIN ----------------------------------------------------- */
int main(void)
{
    if (SEED) srand(SEED); else srand((unsigned)time(NULL));

    /* AWGN parameters */
    double rate = pow((double)K / N, 2.0);        /* product-code rate */
    double EsN0dB = EB_N0_DB + 10.0 * log10(2.0 * rate);
    double sigma = 1.0 / sqrt(pow(10.0, EsN0dB / 10.0));

    unsigned ok = 0, bit_err = 0;
    const unsigned total_bits = NUM_SIM * K * K;

    printf("Starting %d simulations …\n\n", NUM_SIM);

    for (unsigned run = 0; run < NUM_SIM; ++run) {

        /* --- 1. random K×K information block ----------------------- */
        uint8_t u[K][K];
        for (size_t r = 0; r < K; ++r)
            for (size_t c = 0; c < K; ++c)
                u[r][c] = (urand() > 0.5);

        /* --- 2. encode to N×N product code ------------------------- */
        uint8_t c_mat[N][N] = {0};

        /* copy information */
        for (size_t r = 0; r < K; ++r)
            for (size_t c = 0; c < K; ++c)
                c_mat[r][c] = u[r][c];

        /* (a) row CRC → parity columns */
        for (size_t r = 0; r < K; ++r)
            for (size_t j = K; j < N; ++j) {
                uint8_t sum = 0;
                for (size_t i = 0; i < K; ++i)
                    sum ^= u[r][i] & G[i][j];
                c_mat[r][j] = sum;
            }

        /* (b) column CRC → parity rows */
        for (size_t c = 0; c < N; ++c)
            for (size_t j = K; j < N; ++j) {
                uint8_t sum = 0;
                for (size_t i = 0; i < K; ++i)
                    sum ^= c_mat[i][c] & G[i][j];
                c_mat[j][c] = sum;
            }

        /* --- 3. channel: BPSK + one random flip + AWGN ------------ */
        double Lch[N][N];
        size_t flip_r = rand() % N, flip_c = rand() % N;

        for (size_t r = 0; r < N; ++r)
            for (size_t c = 0; c < N; ++c) {
                double x = 1.0 - 2.0 * c_mat[r][c];  /* BPSK */
                if (r == flip_r && c == flip_c) x = -x; /* hard flip */
                x += sigma * gauss_rand();
                Lch[r][c] = 2.0 * x / (sigma * sigma);
            }

        /* --- 4. iterative decoding -------------------------------- */
        double L_APP[N][N] = {{0}};
        double L_E  [N][N] = {{0}};

        for (int it = 0; it < I_MAX; ++it) {

            /* rows */
            for (size_t r = 0; r < N; ++r) {
                double in[N], Lap[N], Le[N];
                for (size_t i = 0; i < N; ++i)
                    in[i] = Lch[r][i] + ALPHA * L_E[r][i];
                sogrand_W01(in, H, Lap, Le);
                for (size_t i = 0; i < N; ++i) {
                    L_APP[r][i] = Lap[i];
                    L_E  [r][i] = Le [i];
                }
            }

            /* columns */
            for (size_t c = 0; c < N; ++c) {
                double in[N], Lap[N], Le[N];
                for (size_t i = 0; i < N; ++i)
                    in[i] = Lch[i][c] + ALPHA * L_E[i][c];
                sogrand_W01(in, H, Lap, Le);
                for (size_t i = 0; i < N; ++i) {
                    L_APP[i][c] = Lap[i];
                    L_E  [i][c] = Le [i];
                }
            }

            /* early exit */
            uint8_t cHD[N][N];
            for (size_t r = 0; r < N; ++r)
                for (size_t c = 0; c < N; ++c)
                    cHD[r][c] = (L_APP[r][c] > 0.0) ? 0 : 1;
            if (prod_syndrome_zero(cHD)) break;
        }

        /* --- 5. extract hat{u} & stats ----------------------------- */
        unsigned err_run = 0;
        for (size_t r = 0; r < K; ++r)
            for (size_t c = 0; c < K; ++c) {
                uint8_t d = (L_APP[r][c] > 0.0) ? 0 : 1;
                if (d != u[r][c]) ++err_run;
            }

        if (err_run == 0) ++ok;
        else              bit_err += err_run;
    }

    /* --- 6. report ----------------------------------------------- */
    double acc  = 100.0 * ok / (double)NUM_SIM;
    double ber  = (double)bit_err / total_bits;

    puts("=============================================");
    puts("           FINAL SIMULATION REPORT           ");
    puts("=============================================");
    printf("Total Simulations Run:      %d\n", NUM_SIM);
    printf("Successful Decodes:         %u\n", ok);
    printf("Failed Decodes:             %u\n", NUM_SIM - ok);
    puts("---------------------------------------------");
    printf("Overall Decoding Accuracy:  %.2f %%\n", acc);
    printf("Average Bit Error Rate (BER): %.2e\n", ber);
    puts("=============================================");

    return 0;
}
